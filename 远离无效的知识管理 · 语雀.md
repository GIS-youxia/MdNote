# 远离无效的知识管理 · 语雀
随着互联网的繁荣发展，信息传播的多样化和速度已经发生了质的飞跃，人们获取信息越来越容易，业界各类有识之士纷纷买票上车，大力向外界传播自己的知识，或是出于公益而免费普及，或是出于利益而付费变现。  

在这样信息大爆炸的时代下，诞生了一个新的名词：知识焦虑。以至于一些网络人士给现在某些互联网知识平台定位为贩卖焦虑的平台。  

作为程序员，暂且不必参合到那些舆论中，回到自己的领域，我们不得接受的一个事实是：在软件开发中，也充斥着海量的知识。比如，开发方法论、研发流程、业务需求、技术方案、系统架构、编程范式等等。除了这个事实，我们还不得不面对一个问题：软件研发中很可能会因为知识越多，反而越难行动。就拿困扰研发团队多年的文档问题来讲，那些在研发过程中制造了大量文档的团队，文档的维护无疑成为了团队前进的负担。  

在知识的生产上，需要区分有效的知识和无效的知识。有效的知识包括那些能够被团队成员消化吸收，帮助解决问题，并进一步内化成认知的知识。有效知识的转化通常会经历四个阶段：生产 --> 传递 --> 运用 --> 吸收。生产的知识首先要发生传递，知识接受者能将其运用到工作和生活中并解决了实际问题，经过四个阶段的转化，伴随着问题的解决，能力和认知将得到提升。  

![](https://cdn.nlark.com/yuque/0/2021/png/104324/1637891803231-993df2fa-b61b-4c37-92ce-3d7ad4fe1673.png?x-oss-process=image%2Fresize%2Cw_550%2Climit_0)

团队有些时候更多关注了知识生产，这种大量的知识生产会给自己一种幻觉，觉得团队 “学富五车”，知识库这么殷实，战斗力不爆棚都难。秉承着既然生产出来了就不能白费，然后想法设法要这些知识传播出去。可是，这些知识能否经受住这几个拷问吗：  

1 学过了吗？  
2 运用了吗？  
3 认知提升了吗？  
4 足够了吗？  

针对上面的问题，就拿身边知识焦虑的真实例子来讲：  

1 花钱买了付费课程，没打开过 -- 没学习，铁定无效  
2 每天就想写写代码，不想跟人打交道，刚学完沟通表达技巧的课程长时间用不上 -- 没运用，仍旧无效  
3 最近倒是有一次机会去跟人交流，课程里面的技巧用上了两个，但没用好，就那样吧 -- 没反思，终究遗忘  
4 学习了这些单向传播的课程，有很多疑问，从未找过别人探讨 -- 不可言说的知识，无法习得  

在软件开发中，只要是团队作战，个体之间必然存在认知的差异，要提升团队的协作效率和研发效能，就要想办法弥补这种认知差异，尽可能消除由它带来的负面影响。团队可能已经尝试通过一些知识管理手段来缓解这种局面，但在知识管理上，如果无法正面回答上述几个问题，很有可能偏离轨道。不妨停下来，尝试诊断出无效的知识管理，而要做到这一点，对知识要有深刻的认识，进而采取针对性的管理手段。  

知识的分类  

知识可以大致被分为 3 类，分别是隐性知识、显性知识、不可言说的知识。  

●隐式知识：能够被明确定义，却没有被显性化的知识。  
●显式知识：能够被明确定义，并且被显性化的知识。  
●不可言说知识：虽然被显性化，却无法还原回有用技能的知识。  

隐性知识一旦被显性化呈现出来，它就可以转化为显式知识。比如公司的请假流程，公司在刚开始建立的时候，人数很少，还没有什么限制，请假流程也很简单，每个人都记得清楚。此时这种请假流程就属于隐性知识，它存在于每个人的脑子里。随着公司发展壮大，请假流程逐渐复杂起来，此时需要将请假流程明文写下来放到员工手册上，请假流程就变成了显性知识，而且这种显性知识传递出去之后就立马解决如何请假的问题。  

上述两类知识相对容易理解，最难区分的是不可言说的知识，关于不可言说的知识，来看一则庄子的寓言故事：  

在春秋战国时代，有一位擅长做车轮的能工巧匠，他的名字叫轮扁。　　  

一天，齐桓公在殿堂上读书，轮扁在堂下砍削车轮。齐桓公读书读到妙处，不禁摇头晃脑、口中念念有词，很是得意。轮扁见桓公这样爱书，心里觉得纳闷。  

他放下手中的锥子、凿子，走到堂上问齐桓公说：“请问，大王您所看的书，上面写的都是些什么呀？”  

齐桓公回答说：“书上写的是圣人讲的道理。”  

轮扁说：“请问大王，这些圣人还活着吗？”  

齐桓公说：“他们都死了。”  

于是轮扁说：“那么，大王您所读的书，不过是古人留下的糟粕罢了。”  

齐桓公很是扫兴。他对轮扁说：“我在这里读书，你一个做车轮的工匠，凭什么瞎议论呢？你说圣人书上留下的是糟粕，如果你能谈出个道理来，我还可以饶了你，如果你说不出道理来，我非杀你不可！”  

轮扁不紧不慢地回答齐桓公说：“我是从自己的职业和经验体会来看待这件事的。就说我砍削车轮这件事吧，速度慢了，车轮就削得光滑但不坚固；动作快了，车轮就削得粗糙而不合规格。只有不快不慢，才能得心应手，制作出质量最好的车轮。由此看来，削车轮也有它的规律。可是，我只能从心里去体会而得到，却难以用言语很清楚明白他讲授给我儿子听，因此我儿子便不能从我这里学到砍削车轮的真正技巧，所以我已经 70 岁了，还得凭自己心里的感觉去动手砍削车轮。由此可见，古代圣人心中许多只可意会、不可言传的知识精华已经随着他们死去了，那么大王您今天所能读到的，当然只能是一些古人留下的肤浅粗略的东西了。”  

不可言说的知识即便用文字记录下来，白纸黑字人人都懂，但就是差那么一点得心应手感觉。比如，你去给一个人讲：好的软件设计应该是高内聚低耦合，且应该遵循单一职责。你觉得听者听了之后就能做出好的设计吗？要是就凭三言两语就能搞定，软件行业的遗留系统恐怕就没这么难缠了吧。  

软件开发中的知识  

显性知识  

在软件开发活动中，识别出那些非不可言说的知识相对较为容易。比如一些新人 On-boarding 流程、团队组成、CI 纪律、请假流程、团队开发活动、代码库、技术栈等等，这些知识有一个公共的特点，几乎所有人对这些知识的理解不会出现二义性，而且一旦获取，就能够有效解决问题。比如，一个刚加入团队的新人拿着这些显性知识：  

1 清楚接下来两周要做什么事情  
2CI 挂了不会继续提交  
3 请假给正确的人发邮件  
4 准时参加每日站会和 Code Review，每个迭代末主持 Showcase 会议  
5 找到了代码库，下载并构建代码库  

当然，新人在接收到显性知识之后也有可能犯错，但这通常是个人主观的造成的，这种错误较容易进行纠正，只要再次回顾一下原来的知识基本上能搞定。  

隐性知识  

有些时候，上述列举的显性知识被存储在团队每个人的大脑中。尤其是团队初期，很多知识相对简单，团队对齐过之后便基本上能记住，这种被记住却又没有地方能找到显性记录的知识就属于隐性知识，所以，隐性知识，就是能够被明确定义，只是没有被显性化，一旦显性化之后就变身显性知识。  

识别隐性知识也简单，每当有人不清楚什么事情的时候，通过询问团队其他成员就立马能获得有效知识，如果这种现象反复发生，多半这里隐藏着是一个隐形知识。  

不可言说的知识  

不可言说的知识可能会有更多的争议，因为很多知识看起来可以通过文字写下来，会给人一种错觉，而实际上即便它们被显性化，消费者无法很快有效运用去解决问题，比如，整洁代码、软件架构、业务需求。  

整洁代码，什么样的代码是整洁代码，业界有名的几本书《整洁代码之道》《编写可读代码的艺术》里面给出了很多定义，看过这两本书的人不少，能写出整洁代码的人多吗？  

重构，《重构》一书中定义了很多坏味道和重构手法，然而代码重构的瓶颈不在于这些白纸黑字写的知识，而是如何在一个千奇百怪的代码海洋中有效识别出有问题的代码。仅仅依循书中定义的 20 多种坏味道 + 60 多种手法，一个设计不良的软件系统恐怕也不那么容易搞定吧。  

软件架构，架构由不同类型的组件以及组件之间的交互组成。很多团队在项目初期会给出了明确清晰的架构设计文档和架构图。然而，当出现新需求，如何按照架构把需求分解到不同组件上的功能，架构图你告诉你怎么做吗？即便架构图清楚了定义了不同层级的组件，很多人仍然无法正确分解。所以，架构的腐化很多情况下是由于对架构不恰当的认知导致对组件功能不当划分所造成的。而软件架构作为系统需求功能拆分的一种指导原则，属于不可言说的知识。  

避开知识管理的陷阱  

不同类型的知识要想有效管理起来需要对症下药。在软件开发中，显式知识相对容易管理，可以通过文字、图像、录音等形式来承载和传递，比如说请假流程可以写出来放在团队的文档库中，CI 纪律打印出来贴在 CI 墙边。而隐性知识显性化通常也不是一件难事，投入相应时间去生产，偶尔做些频率不高的更新即可，比如某些项目的代码库分布和使用过的技术栈，掌握了信息的当事人将它写下来就可以变成显性知识。  

管理显性知识要注意呈现形式的良好结构化和图例化，要做好这点，多迭代几次通常就能达到。最棘手的对不可言说知识的管理，在不可言说的知识上，团队很容易掉入一个常见的陷阱 -- 企图遵循显性知识的管理方式。  

前文列举的几类不可言说的知识如果仅仅通过记录就能达到知识的有效运用，市面上那么多的书，做好软件开发恐怕已经不是什么难事。如果团队没有意识到这种不可言说知识的特殊性，付出过多的努力去编写各种文档和指南，希望以此解决团队认知的差异，在这条路上大多会举步维艰。大量历史实践已经证实了文档过重不但创造不了跟成本相匹配的收益，还额外增加了维护成本，甚至会让团队进退两难，如食鸡肋 -- 继续维护又很艰苦，不维护又可惜。  

一个典型的例子就是传统软件开发中的需求文档和详细设计文档，编写这些文档的人谁能怀疑说他们编写的时候没有认真思考和仔细推敲。开发人员接到这些文档的何尝不是细心研读，然后一番精心设计之后勤奋编码，测试人员拿着放大镜生怕漏掉某个不起眼的重点文字，手点麻了各种按钮和页面。可最终开发出来的软件又怎么样，扪心自问一下，能让业务方开心吗？业务不开心没关系呀，改不就得了！可改起来困难啊！困难没事儿呀，我们有的是时间和钱... 我只能说这是赤裸裸的财大气粗地耍流氓，不改变走不长远，我们也不去过多讨论这种场景。  

重型需求设计文档就是典型想把不可言说的业务知识（想法）通过明确定义的显性知识来管理起来。这个问题早就没什么新鲜感，而解决方案也已烂大街。企图用这种方式来凑效的组织和团队，如果不尝试做出一些调整，恐怕将力量使错了地方，犹如抓沙，越用力留下的越少。  

当然，根治这个毛病不只是认识到知识管理陷阱这么简单，还有更深层的组织管理等利益关系在里面，这些弊端相信时代的潮流会将它扭转过来。而作为知识工作者，我们从知识管理的本质视角切入。  

驾驭不可言说的知识  

要避开不可言说知识管理的陷阱，根本用不着什么广大神通，答案早就在我们身边。前文列举软件开发中的一些不可言说的知识，针对这些知识，如果引入一些社交活动会怎么样呢？比如，如何写出整洁代码，结对编程是一种很有效的方式，这种模式下通过老带新不断能够快速传递业务知识，还能在结对过程中产生对整洁代码的探讨和有效的认知提升。再比如，Code Review 这项团队活动，大伙儿聚在一块讨论同一块代码，众人拾柴火焰高，团队里总有人看不惯别人的设计，提出好的点子，而总有人不接受，那就扒拉扒拉讨论一番，然后达成共识，不可言说的整洁代码就出来了，但整洁代码是什么，仍然无人可以给出能够有效指导他人写出整洁代码的建议，有何妨呢？  

回到知识消费环，生产 --> 传递 --> 运用 --> 吸收，不可言说的知识的消费不能仅靠显性知识的输入，需要不同观点的碰撞，不同理解的交融，在思辨中打破自己原有的认知，从而形成新的理解，而这种在当时特定场景下形成的理解也不一定就能快速吸收，还需要不断地场景迁移，看能否将理解应用在不同的场景，经过几个这样的回合，能举一反三了，则说明认知得到提升，达到了吸收内化。  

要形成有效的知识消费闭环，社交活动是必不可少的，这也是驾驭不可言说知识的核心。  

再比如系统架构，好的系统架构应该是出自团队，通过演进式浮现出来，而不是某个人在一张白纸上画几个线框图搞出来的。为什么这么设计？这么设计之后不同的业务功能应该划分到哪个组件？未来业务复杂度更高了，非功能性需求变更了，系统应该怎么演变？同样一张架构设计图不同人理解是不一样的，要有效传递系统架构背后的设计理念，需要团队通过定期的探讨和复盘，在动态的沟通过程中达成共识，从而指导对架构的演化。  

关于不可言说的知识，不得不说说业务需求。根据 2019 年中国 DevOps 现状调查报告数据显示，软件被延迟交付是困扰很多开发团队的一个现象，超半数企业认为需求的频繁变更是阻碍软件按时交付的主要原因。  

需求的频繁变更

59.68%

集成问题太多

38.71%

缺少团队间的沟通

31.35%

测试占据太长时间

23.58%

整个项目预估有偏差

17.88%

每个环节等待审批时间过长

14.52%

软件被延迟交付的原因

![](https://cdn.nlark.com/yuque/0/2021/png/104324/1622163655877-0b37ac16-0765-45b1-987f-6d0260cf2459.png?x-oss-process=image%2Fresize%2Cw_735%2Climit_0)

需求变更是导致软件延期的最大元凶，尤其是在一些传统瀑布开发流程的组织中，企图通过重型文档和强审核流程规范开发过程，强流程管控 + 重需求文档必然导致组织对需求变更的响应力不足，而需求变更又是不可避免的。业务需求很多时候属于不可言说的知识（业务人员的想法），针对这种不可言说的知识，好的方式是通过沟通交流达成共识，再借助显性化知识管理手段来记录和传递。这也是为什么敏捷软件开发中不提倡重量级需求文档，提倡基于个体交互的沟通共识的原因。  

传递不可言说的知识离不开有效的社交活动，而社交活动也稍微需要点讲究，最好形成「沟通 - 确认」循环，即 Kick-Off ~ Review，简称 KR 环。Kick off 中传递知识，沟通达成初步共识，再通过 Review 来检视行动结果。每一次沟通循环必然会深化共识，人员认知也会随之得到提升。  

Kick off ~ Review 的社交循环需要注意几点：  

1 闭环。善始善终，有始有终，切勿在 Kick off 的时候兴致满满，而 Review 草草了之。  
2 及时。Kick off ~ Review 的时间间隔适当，太长了上下文可能已经淡化，影响知识传递效果。  
3 记录。通过轻量的方式将沟通共识后的要点记录下来，建议将沟通过程中的一些片段也进行记录，便于回忆。  

在软件开发项目中，绝大部分知识属于不可言说的知识，当你发现团队中知识传递效率低，不妨回顾一下团队的社交活动是不是存在问题，考虑是否要增加 Kick off - Review 循环或者缩短循环周期以进行高效的沟通。  

![](https://cdn.nlark.com/yuque/0/2021/png/104324/1637891967512-5919da28-6c60-4117-9abe-72d375120218.png?x-oss-process=image%2Fresize%2Cw_550%2Climit_0)

写在最后  

太阳底下无新鲜事，排列组合便是创新。其实在基于迭代的敏捷软件开发过程中，有很多敏捷实践都其实是在做社交循环，典型的有 “IPM - Showcase”、“Story off - Story Desk check”，“Coding - Code Review”，“任务分解 - 功能实现”，结对编程。  

如果把软件开发当成是一种知识传递的过程，它起源于创意或想法，首先将某人脑中的想法转化为需求，再通过编码实现转化为代码，最终通转化为可工作的软件。在这个过程会涉及到大量的知识传递，而这些知识大量属于不可言说的知识，如何高效率传递这些知识，并提升团队的认知，是一个值得软件知识工作者去深入探索的问题。  

作为软件开发活动中的知识工作者，切勿让在生产知识上的勤奋掩盖了在思考有效知识管理上的懒惰，最终投入大量精力制造了一推没有被消费掉的知识，还制造了一个 “知识渊博” 和“学富五车”的幻象。  

​

关注作者和知识库后续更新

![](https://cdn.nlark.com/yuque/0/2020/png/104324/1606295120769-avatar/1c6724fa-17db-4a86-8726-67791c58b4c3.png?x-oss-process=image%2Fresize%2Cm_fill%2Cw_64%2Ch_64%2Fformat%2Cpng)

推荐阅读

#### [保龄球（Bowling）](https://www.yuque.com/go/doc/16701297)

阅读本文后，希望你能够有如下收获：掌握保龄球的计分规则，下次打球不再迷茫。通过保龄球的计分系统端到端业务功能分析，避免陷入细节。通过业务抽象产出一份需求任务列表，从而指导下一步的 TDD。如若与你期望相符，欢迎你继续阅读！需求背景请你设计一个计算保龄球比赛一局总得分的程序，保龄球的计分规则如下：...

#### [如何解读 TDD？](https://www.yuque.com/go/doc/16514757)

测试驱动开发是一种软件开发实践，源于 1999 年 Kent Beck《Extreme Programming Explained》一书中的测试先行这一概念。Kent Beck 在 2003 年再次提到 – TDD 鼓励简单的设计并激发信心。经过后期的发展，TDD 已经成长为一门独立的软件开发技术，其名气甚至... 
 [https://www.yuque.com/lean-agile/efficacy/avoid-ineffective-knowledge-manage](https://www.yuque.com/lean-agile/efficacy/avoid-ineffective-knowledge-manage)
